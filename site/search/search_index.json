{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lists A list data structure is a collection data type that allows multiple values to be stored within the same field. Lists are stored in certain chunks of memory which are linked together with pointers, that allows efficient use of memory and doesn't require resizing. \"apple\" , \"orange\" , \"carrot\" and \"pear\" are being stored in a list named foods and the list gets printed out. It then adds \"chocolate\" and \"cake\" to the list, which automatically changes the size of the list. Then prints the list out foods = [\"apple\", \"orange\", \"carrot\", \"pear\"] for i in foods: print(i) print(\"\") print(\"\") foods.append(\"chocolate\") foods.append(\"cake\") for i in foods: print(i) Arrays An array data structure is a data structure that is a fixed size, can be dynamically reallocated, and is efficiently indexed. It stores multiple items of the same type together, which makes it easier to calculate the position of each element. It can not store different types such as integers and floats in one array. We first have to import array as it is before we can use arrays. 1 , 2 , 3 and 4 are integer numbers and are being stored into an integer array named int_array and then gets printed out. 1.1 , 2.2 , 3.3 and 4.4 are float numbers, that are being stored into a float array named float_array and then gets printed out. The 'i' in the int_array indicates that it is an integer array and only integer numbers can be put into the array. The 'f' in the float_array indicates that it is a float array and only float numbers can be put into the array import array int_array = array.array('i', [1, 2, 3, 4]) float_array = array.array('f', [1.1, 2.2, 3.3, 4.4]) for i in int_array: print(i) for a in float_array: print(a) Linked Lists Linked lists are an ordered collection of objects. Linked lists are different from lists because of the way they store elements in memory. While lists use a contiguous memory block to store references to their data, linked lists store references as a part of their own element. A linked list is a collection of nodes, where the first node is the head , and is used as the starting point for any iteration through the list. The last node must have its next reference pointing to None to detemine the end of the list. Each element of a linked list is called a node where every node has two different fields: Data - The value to be stored in the node Next - A reference to the next node on the list. So first we create the Node class and a class that uses the Node class called Slinkedlist . We then give the values to the node that goes to the Next data element. class Node: def __init__(self, data=None): self.data = data self.next = None class SLinkedList: def __init__(self): self.head = None def listprint(self): printval = self.head while printval is not None: print(printval.dataval) printval = printval.nextval Slist = SLinkedList() Slist.head = Node(\"Mon\") element2 = Node(\"Tue\") element3 = Node(\"Wed\") Slist.head.next = element2 element2.next = element3 Slist.listprint() Stack A stack is a linear data structure that stores items in a LIFO (Last-In/First-Out) way. So the last element you add to the stack, will be the first element to come off the stack. The insert and delete operations are usually called push and pop. We have 3 elements being added to the stack: 1 , 2 and 3 . Because 3 was added on last, the first pop will remove 3 from the stack, then remove 2 , and then finally 1 . stack = [] stack.append(1) stack.append(2) stack.append(3) print(\"First stack\") print(stack) print(\"Popped from stack:\") print(stack.pop()) print(stack.pop()) print(stack.pop()) print(\"Stack after the pops\") print(stack) Queues Queues are like stacks in the fact that they are a linear data structure. However, they store items in FIFO (First-In/First-Out) way. So the first element to be added to the stack, will be the first element to come off the stack. We have 3 elements being added to the queue: 1 , 2 and 3 . Because 1 was added on first, the first pop will remove 1 from the stack, then remove 2 , and then finally 3 . queue = [] queue.append(1) queue.append(2) queue.append(3) print(\"First queue\") print(queue) print(\"Dequeued from queue\") print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) print(\"Queue after the dequeing\") print(queue) Trees A tree data structure is where data elements are connected using references in a hierarchical manner. A tree consists of a root node, which is the top of the tree. Root Node - The topmost node of a tree. It's always the first node created when creating the tree. In the tree below, 50 would be the root node. Parent Node - The parent of any node is the node which is above the current node. With the tree below, 20 would be the parent of 11 , 46 and 15 . 50 is the root but also the parent node of 20 and 45 . Child Node - The child node is the node below the parent. The tree below, 30 and 78 are child nodes of the parent node 45 . Edge - The edge is the reference which a parent node is connected to a child node. It's like a path from the parent node to child node. Leaf Node - The leaf node is the last node that doesn't have a child. With the tree below, 11 , 46 , 15 , 30 and 78 are all leaf nodes. Internal Nodes - They are nodes that have atleast one child node. Examples with the tree below, 50 , 20 and 45 are internal nodes. Graphs Graphs are complex, non-linear data structures that are made by a group of vertices, connected by edges. Vertices - Vertices are what's in a graph. Every vertex has a value that is associated with it. An example would be a list of houses using a graph, the vertices would represent the houses. Edges - Edges is the relationship between the vertices in the graph. Edges may or may not have a vlue associated with them. An example would be a list of towns using a graph, the edges would be the road between the houses. Here we have a graph that has 3 vertices. The cost of moving from vertex 0 to vertex 1 is 1. Where as the cost of moving from vertex 0 to vertex 2 is 2. When moving from a vertex to itself, it is usually 0. graph = [[0, 1, 2], [2, 0, 5], [4, 5, 0]] Sets A set data structure is an unordered collection of items. Every element is unique meaning there cannot be duplicates of an element, and cannot be changed. However, you can add or remove items from it. A set is created by placing all the elements inside curly braces {} , seperated by comma. Here, we have a set of values 1 , 2 , 3 , 4 , 3 and 2 . However, after the 4 , the 3 and 2 are not added as they are duplicates. So we get an output of {1, 2, 3, 4} my_set = {1, 2, 3, 4, 3, 2} print(my_set) Hash tables Hash tables are a type of data structure that the index value of the data element is generated from a hash function. This makes accessing data faster as the index value is like a key for the data value. In Python, the Dictionary data types represent the implementation of hash tables. Here, we have 3 keys: Name - With the data value: Callum Age - With the data value: 20 Class - With the data value: Programming We can then print out the Name and Age by using the key. dict = {'Name': 'Callum', 'Age': '20', 'Class': 'Programming'} print(\"Name: \", dict['Name']) print(\"Age: \", dict['Age'])","title":"Home"},{"location":"#lists","text":"A list data structure is a collection data type that allows multiple values to be stored within the same field. Lists are stored in certain chunks of memory which are linked together with pointers, that allows efficient use of memory and doesn't require resizing. \"apple\" , \"orange\" , \"carrot\" and \"pear\" are being stored in a list named foods and the list gets printed out. It then adds \"chocolate\" and \"cake\" to the list, which automatically changes the size of the list. Then prints the list out foods = [\"apple\", \"orange\", \"carrot\", \"pear\"] for i in foods: print(i) print(\"\") print(\"\") foods.append(\"chocolate\") foods.append(\"cake\") for i in foods: print(i)","title":"Lists"},{"location":"#arrays","text":"An array data structure is a data structure that is a fixed size, can be dynamically reallocated, and is efficiently indexed. It stores multiple items of the same type together, which makes it easier to calculate the position of each element. It can not store different types such as integers and floats in one array. We first have to import array as it is before we can use arrays. 1 , 2 , 3 and 4 are integer numbers and are being stored into an integer array named int_array and then gets printed out. 1.1 , 2.2 , 3.3 and 4.4 are float numbers, that are being stored into a float array named float_array and then gets printed out. The 'i' in the int_array indicates that it is an integer array and only integer numbers can be put into the array. The 'f' in the float_array indicates that it is a float array and only float numbers can be put into the array import array int_array = array.array('i', [1, 2, 3, 4]) float_array = array.array('f', [1.1, 2.2, 3.3, 4.4]) for i in int_array: print(i) for a in float_array: print(a)","title":"Arrays"},{"location":"#linked-lists","text":"Linked lists are an ordered collection of objects. Linked lists are different from lists because of the way they store elements in memory. While lists use a contiguous memory block to store references to their data, linked lists store references as a part of their own element. A linked list is a collection of nodes, where the first node is the head , and is used as the starting point for any iteration through the list. The last node must have its next reference pointing to None to detemine the end of the list. Each element of a linked list is called a node where every node has two different fields: Data - The value to be stored in the node Next - A reference to the next node on the list. So first we create the Node class and a class that uses the Node class called Slinkedlist . We then give the values to the node that goes to the Next data element. class Node: def __init__(self, data=None): self.data = data self.next = None class SLinkedList: def __init__(self): self.head = None def listprint(self): printval = self.head while printval is not None: print(printval.dataval) printval = printval.nextval Slist = SLinkedList() Slist.head = Node(\"Mon\") element2 = Node(\"Tue\") element3 = Node(\"Wed\") Slist.head.next = element2 element2.next = element3 Slist.listprint()","title":"Linked Lists"},{"location":"#stack","text":"A stack is a linear data structure that stores items in a LIFO (Last-In/First-Out) way. So the last element you add to the stack, will be the first element to come off the stack. The insert and delete operations are usually called push and pop. We have 3 elements being added to the stack: 1 , 2 and 3 . Because 3 was added on last, the first pop will remove 3 from the stack, then remove 2 , and then finally 1 . stack = [] stack.append(1) stack.append(2) stack.append(3) print(\"First stack\") print(stack) print(\"Popped from stack:\") print(stack.pop()) print(stack.pop()) print(stack.pop()) print(\"Stack after the pops\") print(stack)","title":"Stack"},{"location":"#queues","text":"Queues are like stacks in the fact that they are a linear data structure. However, they store items in FIFO (First-In/First-Out) way. So the first element to be added to the stack, will be the first element to come off the stack. We have 3 elements being added to the queue: 1 , 2 and 3 . Because 1 was added on first, the first pop will remove 1 from the stack, then remove 2 , and then finally 3 . queue = [] queue.append(1) queue.append(2) queue.append(3) print(\"First queue\") print(queue) print(\"Dequeued from queue\") print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) print(\"Queue after the dequeing\") print(queue)","title":"Queues"},{"location":"#trees","text":"A tree data structure is where data elements are connected using references in a hierarchical manner. A tree consists of a root node, which is the top of the tree. Root Node - The topmost node of a tree. It's always the first node created when creating the tree. In the tree below, 50 would be the root node. Parent Node - The parent of any node is the node which is above the current node. With the tree below, 20 would be the parent of 11 , 46 and 15 . 50 is the root but also the parent node of 20 and 45 . Child Node - The child node is the node below the parent. The tree below, 30 and 78 are child nodes of the parent node 45 . Edge - The edge is the reference which a parent node is connected to a child node. It's like a path from the parent node to child node. Leaf Node - The leaf node is the last node that doesn't have a child. With the tree below, 11 , 46 , 15 , 30 and 78 are all leaf nodes. Internal Nodes - They are nodes that have atleast one child node. Examples with the tree below, 50 , 20 and 45 are internal nodes.","title":"Trees"},{"location":"#graphs","text":"Graphs are complex, non-linear data structures that are made by a group of vertices, connected by edges. Vertices - Vertices are what's in a graph. Every vertex has a value that is associated with it. An example would be a list of houses using a graph, the vertices would represent the houses. Edges - Edges is the relationship between the vertices in the graph. Edges may or may not have a vlue associated with them. An example would be a list of towns using a graph, the edges would be the road between the houses. Here we have a graph that has 3 vertices. The cost of moving from vertex 0 to vertex 1 is 1. Where as the cost of moving from vertex 0 to vertex 2 is 2. When moving from a vertex to itself, it is usually 0. graph = [[0, 1, 2], [2, 0, 5], [4, 5, 0]]","title":"Graphs"},{"location":"#sets","text":"A set data structure is an unordered collection of items. Every element is unique meaning there cannot be duplicates of an element, and cannot be changed. However, you can add or remove items from it. A set is created by placing all the elements inside curly braces {} , seperated by comma. Here, we have a set of values 1 , 2 , 3 , 4 , 3 and 2 . However, after the 4 , the 3 and 2 are not added as they are duplicates. So we get an output of {1, 2, 3, 4} my_set = {1, 2, 3, 4, 3, 2} print(my_set)","title":"Sets"},{"location":"#hash-tables","text":"Hash tables are a type of data structure that the index value of the data element is generated from a hash function. This makes accessing data faster as the index value is like a key for the data value. In Python, the Dictionary data types represent the implementation of hash tables. Here, we have 3 keys: Name - With the data value: Callum Age - With the data value: 20 Class - With the data value: Programming We can then print out the Name and Age by using the key. dict = {'Name': 'Callum', 'Age': '20', 'Class': 'Programming'} print(\"Name: \", dict['Name']) print(\"Age: \", dict['Age'])","title":"Hash tables"}]}